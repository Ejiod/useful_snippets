

```sql
CREATE OR REPLACE PROCEDURE clean_existing_names(input_table STRING, output_table STRING)
RETURNS STRING
LANGUAGE PYTHON
RUNTIME_VERSION = '3.8'
PACKAGES = ('pandas', 'regex')
HANDLER = 'clean_existing_names_handler'
AS
$$
import pandas as pd
import regex as re

def clean_existing_names_handler(session, input_table, output_table):
    # Read the input table
    query = f"SELECT * FROM {input_table}"
    df = session.table(query).to_pandas()
    
    # Function to clean individual name parts
    def clean_name_part(name):
        if pd.isna(name):
            return name
        # Remove any non-alphabetic characters except hyphens and apostrophes
        name = re.sub(r"[^a-zA-Z\-']", ' ', str(name))
        # Remove extra spaces
        name = ' '.join(name.split())
        # Capitalize each part of the name
        name = ' '.join(part.capitalize() for part in name.split())
        return name
    
    # Define regex patterns for name columns
    name_patterns = {
        'first_name': r'^(?:first[_\s]?(?:name|nm)|fore[_\s]?(?:name|nm)|given[_\s]?(?:name|nm))$',
        'last_name': r'^(?:last[_\s]?(?:name|nm)|sur[_\s]?(?:name|nm)|family[_\s]?(?:name|nm))$',
        'middle_name': r'^middle[_\s]?(?:name|nm)$'
    }
    
    # Function to find matching column using regex
    def find_matching_column(columns, pattern):
        for col in columns:
            if re.match(pattern, col, re.IGNORECASE):
                return col
        return None
    
    # Clean and standardize name columns
    for std_name, pattern in name_patterns.items():
        matching_col = find_matching_column(df.columns, pattern)
        if matching_col:
            df[std_name] = df[matching_col].apply(clean_name_part)
            if matching_col != std_name:
                df = df.drop(columns=[matching_col])
    
    # Write the result back to Snowflake
    session.write_pandas(df, output_table, auto_create_table=True, overwrite=True)
    
    return f"Names cleaned and saved to {output_table}"

$$;
```

